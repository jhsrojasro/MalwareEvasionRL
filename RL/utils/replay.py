import numpy as np

class MemoryReplay:
    def __init__(self, capacity, observation_shape, minibatch_size) -> None:
        self.capacity = capacity
        self.registered = 0
        self.minibatch_size = minibatch_size
        self.observation_shape = observation_shape
        self.memory_shape = (capacity, observation_shape * 2 + 3) # state, action, reward, next_state, done
        self.memory = np.zeros(self.memory_shape) 
        self.position = 0
    
    def push(self, state, action, reward, next_state, done):
        transition = np.hstack((state, [action, reward], next_state, int(done)))
        self.memory[self.position % self.capacity] = transition
        self.position += 1
        self.registered = min(self.registered + 1, self.capacity)
    
    def sample(self):
        sample = np.random.choice(self.registered, size=self.minibatch_size) if self.registered >= self.minibatch_size else np.random.choice(self.registered, size=self.registered)
        return self.memory[sample]
    
    def clear(self):
        self.memory = np.zeros(self.memory_shape)
        self.position = 0
    
    def is_full(self):
        return self.registered >= self.capacity

    def __len__(self):
        return len(self.memory)

class PPOReplayMemory:
    def __init__(self, batch_size) -> None:
        self.states = []
        self.probs = []
        self.vals = []
        self.actions = []
        self.rewards = []
        self.dones = []
        self.bacth_size = batch_size

    def generate_batches(self):
        n_states = len(self.states)
        batch_start = np.arange(0, n_states, self.bacth_size)
        indices = np.arange(n_states, dtype=np.int64)
        np.random.shuffle(indices)
        batches = [indices[i:i+self.bacth_size] for i in batch_start]

        return np.array(self.states), \
                np.array(self.actions), \
                np.array(self.probs), \
                np.array(self.vals), \
                np.array(self.rewards), \
                np.array(self.dones), \
                batches
    
    def store_memory(self, state, action, probs, vals, reward, done):
        self.states.append(state)
        self.actions.append(action)
        self.probs.append(probs)
        self.vals.append(vals)
        self.rewards.append(reward)
        self.dones.append(done)
    
    def clear_memory(self):
        self.states = []
        self.probs = []
        self.vals = []
        self.actions = []
        self.rewards = []
        self.dones = []


